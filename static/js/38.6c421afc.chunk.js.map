{"version":3,"file":"static/js/38.6c421afc.chunk.js","mappings":"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","sources":["../node_modules/lucid-cardano/esm/src/core/wasm_modules/cardano_message_signing_web/cardano_message_signing.js"],"sourcesContent":["let wasm;\nconst heap = new Array(32).fill(undefined);\nheap.push(undefined, null, true, false);\nfunction getObject(idx) {\n    return heap[idx];\n}\nlet heap_next = heap.length;\nfunction dropObject(idx) {\n    if (idx < 36)\n        return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\nlet cachedTextDecoder = new TextDecoder(\"utf-8\", {\n    ignoreBOM: true,\n    fatal: true,\n});\ncachedTextDecoder.decode();\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null ||\n        cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length)\n        heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n    heap[idx] = obj;\n    return idx;\n}\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == \"number\" || type == \"boolean\" || val == null) {\n        return `${val}`;\n    }\n    if (type == \"string\") {\n        return `\"${val}\"`;\n    }\n    if (type == \"symbol\") {\n        const description = val.description;\n        if (description == null) {\n            return \"Symbol\";\n        }\n        else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == \"function\") {\n        const name = val.name;\n        if (typeof name == \"string\" && name.length > 0) {\n            return `Function(${name})`;\n        }\n        else {\n            return \"Function\";\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = \"[\";\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for (let i = 1; i < length; i++) {\n            debug += \", \" + debugString(val[i]);\n        }\n        debug += \"]\";\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    }\n    else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == \"Object\") {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return \"Object(\" + JSON.stringify(val) + \")\";\n        }\n        catch (_) {\n            return \"Object\";\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\nlet WASM_VECTOR_LEN = 0;\nlet cachedTextEncoder = new TextEncoder(\"utf-8\");\nconst encodeString = typeof cachedTextEncoder.encodeInto === \"function\"\n    ? function (arg, view) {\n        return cachedTextEncoder.encodeInto(arg, view);\n    }\n    : function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length,\n        };\n    };\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n    let len = arg.length;\n    let ptr = malloc(len);\n    const mem = getUint8Memory0();\n    let offset = 0;\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F)\n            break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        offset += ret.written;\n    }\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null ||\n        cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null ||\n        cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n/** */\nexport const LabelKind = Object.freeze({\n    Int: 0,\n    \"0\": \"Int\",\n    Text: 1,\n    \"1\": \"Text\",\n});\n/** */\nexport const SignedMessageKind = Object.freeze({\n    COSESIGN: 0,\n    \"0\": \"COSESIGN\",\n    COSESIGN1: 1,\n    \"1\": \"COSESIGN1\",\n});\n/** */\nexport const SigContext = Object.freeze({\n    Signature: 0,\n    \"0\": \"Signature\",\n    Signature1: 1,\n    \"1\": \"Signature1\",\n    CounterSignature: 2,\n    \"2\": \"CounterSignature\",\n});\n/** */\nexport const CBORSpecialType = Object.freeze({\n    Bool: 0,\n    \"0\": \"Bool\",\n    Float: 1,\n    \"1\": \"Float\",\n    Unassigned: 2,\n    \"2\": \"Unassigned\",\n    Break: 3,\n    \"3\": \"Break\",\n    Undefined: 4,\n    \"4\": \"Undefined\",\n    Null: 5,\n    \"5\": \"Null\",\n});\n/** */\nexport const CBORValueKind = Object.freeze({\n    Int: 0,\n    \"0\": \"Int\",\n    Bytes: 1,\n    \"1\": \"Bytes\",\n    Text: 2,\n    \"2\": \"Text\",\n    Array: 3,\n    \"3\": \"Array\",\n    Object: 4,\n    \"4\": \"Object\",\n    TaggedCBOR: 5,\n    \"5\": \"TaggedCBOR\",\n    Special: 6,\n    \"6\": \"Special\",\n});\n/** */\nexport const AlgorithmId = Object.freeze({\n    /**\n     * r\" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses\n     */\n    EdDSA: 0,\n    \"0\": \"EdDSA\",\n    /**\n     * r\" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag\n     */\n    ChaCha20Poly1305: 1,\n    \"1\": \"ChaCha20Poly1305\",\n});\n/** */\nexport const KeyType = Object.freeze({\n    /**\n     * r\" octet key pair\n     */\n    OKP: 0,\n    \"0\": \"OKP\",\n    /**\n     * r\" 2-coord EC\n     */\n    EC2: 1,\n    \"1\": \"EC2\",\n    Symmetric: 2,\n    \"2\": \"Symmetric\",\n});\n/** */\nexport const ECKey = Object.freeze({\n    CRV: 0,\n    \"0\": \"CRV\",\n    X: 1,\n    \"1\": \"X\",\n    Y: 2,\n    \"2\": \"Y\",\n    D: 3,\n    \"3\": \"D\",\n});\n/** */\nexport const CurveType = Object.freeze({\n    P256: 0,\n    \"0\": \"P256\",\n    P384: 1,\n    \"1\": \"P384\",\n    P521: 2,\n    \"2\": \"P521\",\n    X25519: 3,\n    \"3\": \"X25519\",\n    X448: 4,\n    \"4\": \"X448\",\n    Ed25519: 5,\n    \"5\": \"Ed25519\",\n    Ed448: 6,\n    \"6\": \"Ed448\",\n});\n/** */\nexport const KeyOperation = Object.freeze({\n    Sign: 0,\n    \"0\": \"Sign\",\n    Verify: 1,\n    \"1\": \"Verify\",\n    Encrypt: 2,\n    \"2\": \"Encrypt\",\n    Decrypt: 3,\n    \"3\": \"Decrypt\",\n    WrapKey: 4,\n    \"4\": \"WrapKey\",\n    UnwrapKey: 5,\n    \"5\": \"UnwrapKey\",\n    DeriveKey: 6,\n    \"6\": \"DeriveKey\",\n    DeriveBits: 7,\n    \"7\": \"DeriveBits\",\n});\n/** */\nexport class BigNum {\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {BigNum}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @param {string} string\n     * @returns {BigNum}\n     */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} other\n     * @returns {BigNum}\n     */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/** */\nexport class CBORArray {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORArray.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborarray_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborarray_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORArray}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborarray_from_bytes(ptr0, len0);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n     * @returns {CBORArray}\n     */\n    static new() {\n        var ret = wasm.cborarray_new();\n        return CBORArray.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        var ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {CBORValue}\n     */\n    get(index) {\n        var ret = wasm.cborarray_get(this.ptr, index);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORValue} elem\n     */\n    add(elem) {\n        _assertClass(elem, CBORValue);\n        wasm.cborarray_add(this.ptr, elem.ptr);\n    }\n    /**\n     * @param {boolean} use_definite\n     */\n    set_definite_encoding(use_definite) {\n        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_definite() {\n        var ret = wasm.cborarray_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/** */\nexport class CBORObject {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORObject.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborobject_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborobject_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORObject}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborobject_from_bytes(ptr0, len0);\n        return CBORObject.__wrap(ret);\n    }\n    /**\n     * @returns {CBORObject}\n     */\n    static new() {\n        var ret = wasm.cborobject_new();\n        return CBORObject.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        var ret = wasm.cborobject_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {CBORValue} key\n     * @param {CBORValue} value\n     * @returns {CBORValue | undefined}\n     */\n    insert(key, value) {\n        _assertClass(key, CBORValue);\n        _assertClass(value, CBORValue);\n        var ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORValue} key\n     * @returns {CBORValue | undefined}\n     */\n    get(key) {\n        _assertClass(key, CBORValue);\n        var ret = wasm.cborobject_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @returns {CBORArray}\n     */\n    keys() {\n        var ret = wasm.cborobject_keys(this.ptr);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n     * @param {boolean} use_definite\n     */\n    set_definite_encoding(use_definite) {\n        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_definite() {\n        var ret = wasm.cborobject_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/** */\nexport class CBORSpecial {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORSpecial.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborspecial_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORSpecial}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborspecial_from_bytes(ptr0, len0);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @param {boolean} b\n     * @returns {CBORSpecial}\n     */\n    static new_bool(b) {\n        var ret = wasm.cborspecial_new_bool(b);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @param {number} u\n     * @returns {CBORSpecial}\n     */\n    static new_unassigned(u) {\n        var ret = wasm.cborspecial_new_unassigned(u);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_break() {\n        var ret = wasm.cborspecial_new_break();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_null() {\n        var ret = wasm.cborspecial_new_null();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial}\n     */\n    static new_undefined() {\n        var ret = wasm.cborspecial_new_undefined();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        var ret = wasm.cborspecial_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {boolean | undefined}\n     */\n    as_bool() {\n        var ret = wasm.cborspecial_as_bool(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_float() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_as_float(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r1;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_unassigned() {\n        var ret = wasm.cborspecial_as_unassigned(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/** */\nexport class CBORValue {\n    static __wrap(ptr) {\n        const obj = Object.create(CBORValue.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborvalue_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORValue}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_from_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Int} int\n     * @returns {CBORValue}\n     */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.cborvalue_new_int(int.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CBORValue}\n     */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {string} text\n     * @returns {CBORValue}\n     */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_text(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORArray} arr\n     * @returns {CBORValue}\n     */\n    static new_array(arr) {\n        _assertClass(arr, CBORArray);\n        var ret = wasm.cborvalue_new_array(arr.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORObject} obj\n     * @returns {CBORValue}\n     */\n    static new_object(obj) {\n        _assertClass(obj, CBORObject);\n        var ret = wasm.cborvalue_new_object(obj.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {TaggedCBOR} tagged\n     * @returns {CBORValue}\n     */\n    static new_tagged(tagged) {\n        _assertClass(tagged, TaggedCBOR);\n        var ret = wasm.cborvalue_new_tagged(tagged.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {CBORSpecial} special\n     * @returns {CBORValue}\n     */\n    static new_special(special) {\n        _assertClass(special, CBORSpecial);\n        var ret = wasm.cborvalue_new_special(special.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue}\n     */\n    static from_label(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cborvalue_from_label(label.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        var ret = wasm.cborvalue_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Int | undefined}\n     */\n    as_int() {\n        var ret = wasm.cborvalue_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {CBORArray | undefined}\n     */\n    as_array() {\n        var ret = wasm.cborvalue_as_array(this.ptr);\n        return ret === 0 ? undefined : CBORArray.__wrap(ret);\n    }\n    /**\n     * @returns {CBORObject | undefined}\n     */\n    as_object() {\n        var ret = wasm.cborvalue_as_object(this.ptr);\n        return ret === 0 ? undefined : CBORObject.__wrap(ret);\n    }\n    /**\n     * @returns {TaggedCBOR | undefined}\n     */\n    as_tagged() {\n        var ret = wasm.cborvalue_as_tagged(this.ptr);\n        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);\n    }\n    /**\n     * @returns {CBORSpecial | undefined}\n     */\n    as_special() {\n        var ret = wasm.cborvalue_as_special(this.ptr);\n        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);\n    }\n}\n/** */\nexport class COSEEncrypt {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEEncrypt}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt_from_bytes(ptr0, len0);\n        return COSEEncrypt.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSERecipients}\n     */\n    recipients() {\n        var ret = wasm.coseencrypt_recipients(this.ptr);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @param {COSERecipients} recipients\n     * @returns {COSEEncrypt}\n     */\n    static new(headers, ciphertext, recipients) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(recipients, COSERecipients);\n        var ret = wasm.coseencrypt_new(headers.ptr, ptr0, len0, recipients.ptr);\n        return COSEEncrypt.__wrap(ret);\n    }\n}\n/** */\nexport class COSEEncrypt0 {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt0.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt0_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEEncrypt0}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_from_bytes(ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @returns {COSEEncrypt0}\n     */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n}\n/** */\nexport class COSEKey {\n    static __wrap(ptr) {\n        const obj = Object.create(COSEKey.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosekey_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSEKey}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosekey_from_bytes(ptr0, len0);\n        return COSEKey.__wrap(ret);\n    }\n    /**\n     * @param {Label} key_type\n     */\n    set_key_type(key_type) {\n        _assertClass(key_type, Label);\n        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);\n    }\n    /**\n     * @returns {Label}\n     */\n    key_type() {\n        var ret = wasm.cosekey_key_type(this.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} key_id\n     */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} algorithm_id\n     */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    algorithm_id() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Labels} key_ops\n     */\n    set_key_ops(key_ops) {\n        _assertClass(key_ops, Labels);\n        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);\n    }\n    /**\n     * @returns {Labels | undefined}\n     */\n    key_ops() {\n        var ret = wasm.cosekey_key_ops(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} base_init_vector\n     */\n    set_base_init_vector(base_init_vector) {\n        var ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    base_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue | undefined}\n     */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cosekey_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @param {CBORValue} value\n     */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.cosekey_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n     * @param {Label} key_type\n     * @returns {COSEKey}\n     */\n    static new(key_type) {\n        _assertClass(key_type, Label);\n        var ret = wasm.cosekey_new(key_type.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/** */\nexport class COSERecipient {\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipient.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipient_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipient_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSERecipient}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipient_from_bytes(ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} ciphertext\n     * @returns {COSERecipient}\n     */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext)\n            ? 0\n            : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n}\n/** */\nexport class COSERecipients {\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipients.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipients_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipients_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSERecipients}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipients_from_bytes(ptr0, len0);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n     * @returns {COSERecipients}\n     */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {COSERecipient}\n     */\n    get(index) {\n        var ret = wasm.coserecipients_get(this.ptr, index);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n     * @param {COSERecipient} elem\n     */\n    add(elem) {\n        _assertClass(elem, COSERecipient);\n        wasm.coserecipients_add(this.ptr, elem.ptr);\n    }\n}\n/** */\nexport class COSESign {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESign}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign_from_bytes(ptr0, len0);\n        return COSESign.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    signatures() {\n        var ret = wasm.cosesign_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} payload\n     * @param {COSESignatures} signatures\n     * @returns {COSESign}\n     */\n    static new(headers, payload, signatures) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload)\n            ? 0\n            : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signatures, COSESignatures);\n        var ret = wasm.cosesign_new(headers.ptr, ptr0, len0, signatures.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/** */\nexport class COSESign1 {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESign1}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_from_bytes(ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * For verifying, we will want to reverse-construct this SigStructure to check the signature against\n     * # Arguments\n     * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.\n     * @param {Uint8Array | undefined} external_aad\n     * @param {Uint8Array | undefined} external_payload\n     * @returns {SigStructure}\n     */\n    signed_data(external_aad, external_payload) {\n        var ptr0 = isLikeNone(external_aad)\n            ? 0\n            : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(external_payload)\n            ? 0\n            : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_signed_data(this.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array | undefined} payload\n     * @param {Uint8Array} signature\n     * @returns {COSESign1}\n     */\n    static new(headers, payload, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload)\n            ? 0\n            : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);\n        return COSESign1.__wrap(ret);\n    }\n}\n/** */\nexport class COSESign1Builder {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1Builder.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1builder_free(ptr);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} payload\n     * @param {boolean} is_payload_external\n     * @returns {COSESign1Builder}\n     */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESign1Builder.__wrap(ret);\n    }\n    /** */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n     * @param {Uint8Array} external_aad\n     */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {SigStructure}\n     */\n    make_data_to_sign() {\n        var ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} signed_sig_structure\n     * @returns {COSESign1}\n     */\n    build(signed_sig_structure) {\n        var ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n}\n/** */\nexport class COSESignBuilder {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignBuilder.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignbuilder_free(ptr);\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} payload\n     * @param {boolean} is_payload_external\n     * @returns {COSESignBuilder}\n     */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignbuilder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESignBuilder.__wrap(ret);\n    }\n    /** */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n     * @param {Uint8Array} external_aad\n     */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {SigStructure}\n     */\n    make_data_to_sign() {\n        var ret = wasm.cosesignbuilder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @param {COSESignatures} signed_sig_structure\n     * @returns {COSESign}\n     */\n    build(signed_sig_structure) {\n        _assertClass(signed_sig_structure, COSESignatures);\n        var ret = wasm.cosesignbuilder_build(this.ptr, signed_sig_structure.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/** */\nexport class COSESignature {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignature.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignature_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESignature}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_from_bytes(ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n     * @returns {Headers}\n     */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Headers} headers\n     * @param {Uint8Array} signature\n     * @returns {COSESignature}\n     */\n    static new(headers, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n}\n/** */\nexport class COSESignatures {\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignatures.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignatures_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignatures_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {COSESignatures}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignatures_from_bytes(ptr0, len0);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {COSESignature}\n     */\n    get(index) {\n        var ret = wasm.cosesignatures_get(this.ptr, index);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n     * @param {COSESignature} elem\n     */\n    add(elem) {\n        _assertClass(elem, COSESignature);\n        wasm.cosesignatures_add(this.ptr, elem.ptr);\n    }\n}\n/** */\nexport class CounterSignature {\n    static __wrap(ptr) {\n        const obj = Object.create(CounterSignature.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_countersignature_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.countersignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {CounterSignature}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.countersignature_from_bytes(ptr0, len0);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n     * @param {COSESignature} cose_signature\n     * @returns {CounterSignature}\n     */\n    static new_single(cose_signature) {\n        _assertClass(cose_signature, COSESignature);\n        var ret = wasm.countersignature_new_single(cose_signature.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n     * @param {COSESignatures} cose_signatures\n     * @returns {CounterSignature}\n     */\n    static new_multi(cose_signatures) {\n        _assertClass(cose_signatures, COSESignatures);\n        var ret = wasm.countersignature_new_multi(cose_signatures.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n     * @returns {COSESignatures}\n     */\n    signatures() {\n        var ret = wasm.countersignature_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n}\n/** */\nexport class EdDSA25519Key {\n    static __wrap(ptr) {\n        const obj = Object.create(EdDSA25519Key.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eddsa25519key_free(ptr);\n    }\n    /**\n     * @param {Uint8Array} pubkey_bytes\n     * @returns {EdDSA25519Key}\n     */\n    static new(pubkey_bytes) {\n        var ptr0 = passArray8ToWasm0(pubkey_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.eddsa25519key_new(ptr0, len0);\n        return EdDSA25519Key.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} private_key_bytes\n     */\n    set_private_key(private_key_bytes) {\n        var ptr0 = passArray8ToWasm0(private_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.eddsa25519key_set_private_key(this.ptr, ptr0, len0);\n    }\n    /** */\n    is_for_signing() {\n        wasm.eddsa25519key_is_for_signing(this.ptr);\n    }\n    /** */\n    is_for_verifying() {\n        wasm.eddsa25519key_is_for_verifying(this.ptr);\n    }\n    /**\n     * @returns {COSEKey}\n     */\n    build() {\n        var ret = wasm.eddsa25519key_build(this.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/** */\nexport class HeaderMap {\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderMap.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headermap_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {HeaderMap}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headermap_from_bytes(ptr0, len0);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n     * @param {Label} algorithm_id\n     */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    algorithm_id() {\n        var ret = wasm.headermap_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Labels} criticality\n     */\n    set_criticality(criticality) {\n        _assertClass(criticality, Labels);\n        wasm.headermap_set_criticality(this.ptr, criticality.ptr);\n    }\n    /**\n     * @returns {Labels | undefined}\n     */\n    criticality() {\n        var ret = wasm.headermap_criticality(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n     * @param {Label} content_type\n     */\n    set_content_type(content_type) {\n        _assertClass(content_type, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, content_type.ptr);\n    }\n    /**\n     * @returns {Label | undefined}\n     */\n    content_type() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n     * @param {Uint8Array} key_id\n     */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} init_vector\n     */\n    set_init_vector(init_vector) {\n        var ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} partial_init_vector\n     */\n    set_partial_init_vector(partial_init_vector) {\n        var ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n     * @returns {Uint8Array | undefined}\n     */\n    partial_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_partial_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {CounterSignature} counter_signature\n     */\n    set_counter_signature(counter_signature) {\n        _assertClass(counter_signature, CounterSignature);\n        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);\n    }\n    /**\n     * @returns {CounterSignature | undefined}\n     */\n    counter_signature() {\n        var ret = wasm.headermap_counter_signature(this.ptr);\n        return ret === 0 ? undefined : CounterSignature.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @returns {CBORValue | undefined}\n     */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.headermap_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {Label} label\n     * @param {CBORValue} value\n     */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.headermap_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n     * @returns {Labels}\n     */\n    keys() {\n        var ret = wasm.headermap_keys(this.ptr);\n        return Labels.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    static new() {\n        var ret = wasm.headermap_new();\n        return HeaderMap.__wrap(ret);\n    }\n}\n/** */\nexport class Headers {\n    static __wrap(ptr) {\n        const obj = Object.create(Headers.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headers_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Headers}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headers_from_bytes(ptr0, len0);\n        return Headers.__wrap(ret);\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    protected() {\n        var ret = wasm.headers_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    unprotected() {\n        var ret = wasm.headers_unprotected(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n     * @param {ProtectedHeaderMap} protected_\n     * @param {HeaderMap} unprotected_\n     * @returns {Headers}\n     */\n    static new(protected_, unprotected_) {\n        _assertClass(protected_, ProtectedHeaderMap);\n        _assertClass(unprotected_, HeaderMap);\n        var ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);\n        return Headers.__wrap(ret);\n    }\n}\n/** */\nexport class Int {\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n     * @param {BigNum} x\n     * @returns {Int}\n     */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} x\n     * @returns {Int}\n     */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new_negative(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @param {number} x\n     * @returns {Int}\n     */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {BigNum | undefined}\n     */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {BigNum | undefined}\n     */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/** */\nexport class Label {\n    static __wrap(ptr) {\n        const obj = Object.create(Label.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_label_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Label}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_from_bytes(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {Int} int\n     * @returns {Label}\n     */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.label_new_int(int.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {string} text\n     * @returns {Label}\n     */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_new_text(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        var ret = wasm.label_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Int | undefined}\n     */\n    as_int() {\n        var ret = wasm.label_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} id\n     * @returns {Label}\n     */\n    static from_algorithm_id(id) {\n        var ret = wasm.label_from_algorithm_id(id);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} key_type\n     * @returns {Label}\n     */\n    static from_key_type(key_type) {\n        var ret = wasm.label_from_key_type(key_type);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} ec_key\n     * @returns {Label}\n     */\n    static from_ec_key(ec_key) {\n        var ret = wasm.label_from_ec_key(ec_key);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} curve_type\n     * @returns {Label}\n     */\n    static from_curve_type(curve_type) {\n        var ret = wasm.label_from_curve_type(curve_type);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {number} key_op\n     * @returns {Label}\n     */\n    static from_key_operation(key_op) {\n        var ret = wasm.label_from_key_operation(key_op);\n        return Label.__wrap(ret);\n    }\n}\n/** */\nexport class Labels {\n    static __wrap(ptr) {\n        const obj = Object.create(Labels.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_labels_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.labels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Labels}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.labels_from_bytes(ptr0, len0);\n        return Labels.__wrap(ret);\n    }\n    /**\n     * @returns {Labels}\n     */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return Labels.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} index\n     * @returns {Label}\n     */\n    get(index) {\n        var ret = wasm.labels_get(this.ptr, index);\n        return Label.__wrap(ret);\n    }\n    /**\n     * @param {Label} elem\n     */\n    add(elem) {\n        _assertClass(elem, Label);\n        wasm.labels_add(this.ptr, elem.ptr);\n    }\n}\n/** */\nexport class PasswordEncryption {\n    static __wrap(ptr) {\n        const obj = Object.create(PasswordEncryption.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_passwordencryption_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.passwordencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PasswordEncryption}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.passwordencryption_from_bytes(ptr0, len0);\n        return PasswordEncryption.__wrap(ret);\n    }\n    /**\n     * @param {COSEEncrypt0} data\n     * @returns {PasswordEncryption}\n     */\n    static new(data) {\n        _assertClass(data, COSEEncrypt0);\n        var ret = wasm.passwordencryption_new(data.ptr);\n        return PasswordEncryption.__wrap(ret);\n    }\n}\n/** */\nexport class ProtectedHeaderMap {\n    static __wrap(ptr) {\n        const obj = Object.create(ProtectedHeaderMap.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protectedheadermap_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protectedheadermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {ProtectedHeaderMap}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protectedheadermap_from_bytes(ptr0, len0);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    static new_empty() {\n        var ret = wasm.protectedheadermap_new_empty();\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @param {HeaderMap} header_map\n     * @returns {ProtectedHeaderMap}\n     */\n    static new(header_map) {\n        _assertClass(header_map, HeaderMap);\n        var ret = wasm.protectedheadermap_new(header_map.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {HeaderMap}\n     */\n    deserialized_headers() {\n        var ret = wasm.protectedheadermap_deserialized_headers(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n}\n/** */\nexport class PubKeyEncryption {\n    static __wrap(ptr) {\n        const obj = Object.create(PubKeyEncryption.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pubkeyencryption_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pubkeyencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {PubKeyEncryption}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.pubkeyencryption_from_bytes(ptr0, len0);\n        return PubKeyEncryption.__wrap(ret);\n    }\n    /**\n     * @param {COSEEncrypt} data\n     * @returns {PubKeyEncryption}\n     */\n    static new(data) {\n        _assertClass(data, COSEEncrypt);\n        var ret = wasm.pubkeyencryption_new(data.ptr);\n        return PubKeyEncryption.__wrap(ret);\n    }\n}\n/** */\nexport class SigStructure {\n    static __wrap(ptr) {\n        const obj = Object.create(SigStructure.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sigstructure_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SigStructure}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_from_bytes(ptr0, len0);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    context() {\n        var ret = wasm.sigstructure_context(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {ProtectedHeaderMap}\n     */\n    body_protected() {\n        var ret = wasm.sigstructure_body_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {ProtectedHeaderMap | undefined}\n     */\n    sign_protected() {\n        var ret = wasm.sigstructure_sign_protected(this.ptr);\n        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    external_aad() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_external_aad(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_payload(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {ProtectedHeaderMap} sign_protected\n     */\n    set_sign_protected(sign_protected) {\n        _assertClass(sign_protected, ProtectedHeaderMap);\n        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);\n    }\n    /**\n     * @param {number} context\n     * @param {ProtectedHeaderMap} body_protected\n     * @param {Uint8Array} external_aad\n     * @param {Uint8Array} payload\n     * @returns {SigStructure}\n     */\n    static new(context, body_protected, external_aad, payload) {\n        _assertClass(body_protected, ProtectedHeaderMap);\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n}\n/** */\nexport class SignedMessage {\n    static __wrap(ptr) {\n        const obj = Object.create(SignedMessage.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signedmessage_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {SignedMessage}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_bytes(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @param {COSESign} cose_sign\n     * @returns {SignedMessage}\n     */\n    static new_cose_sign(cose_sign) {\n        _assertClass(cose_sign, COSESign);\n        var ret = wasm.signedmessage_new_cose_sign(cose_sign.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @param {COSESign1} cose_sign1\n     * @returns {SignedMessage}\n     */\n    static new_cose_sign1(cose_sign1) {\n        _assertClass(cose_sign1, COSESign1);\n        var ret = wasm.signedmessage_new_cose_sign1(cose_sign1.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @param {string} s\n     * @returns {SignedMessage}\n     */\n    static from_user_facing_encoding(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_user_facing_encoding(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    to_user_facing_encoding() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_user_facing_encoding(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    kind() {\n        var ret = wasm.signedmessage_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {COSESign | undefined}\n     */\n    as_cose_sign() {\n        var ret = wasm.signedmessage_as_cose_sign(this.ptr);\n        return ret === 0 ? undefined : COSESign.__wrap(ret);\n    }\n    /**\n     * @returns {COSESign1 | undefined}\n     */\n    as_cose_sign1() {\n        var ret = wasm.signedmessage_as_cose_sign1(this.ptr);\n        return ret === 0 ? undefined : COSESign1.__wrap(ret);\n    }\n}\n/** */\nexport class TaggedCBOR {\n    static __wrap(ptr) {\n        const obj = Object.create(TaggedCBOR.prototype);\n        obj.ptr = ptr;\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_taggedcbor_free(ptr);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.taggedcbor_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        }\n        finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TaggedCBOR}\n     */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.taggedcbor_from_bytes(ptr0, len0);\n        return TaggedCBOR.__wrap(ret);\n    }\n    /**\n     * @returns {BigNum}\n     */\n    tag() {\n        var ret = wasm.taggedcbor_tag(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n     * @returns {CBORValue}\n     */\n    value() {\n        var ret = wasm.taggedcbor_value(this.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n     * @param {BigNum} tag\n     * @param {CBORValue} value\n     * @returns {TaggedCBOR}\n     */\n    static new(tag, value) {\n        _assertClass(tag, BigNum);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(value, CBORValue);\n        var ret = wasm.taggedcbor_new(ptr0, value.ptr);\n        return TaggedCBOR.__wrap(ret);\n    }\n}\nasync function load(module, imports) {\n    if (typeof Response === \"function\" && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === \"function\") {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            }\n            catch (e) {\n                if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    }\n    else {\n        const instance = await WebAssembly.instantiate(module, imports);\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        }\n        else {\n            return instance;\n        }\n    }\n}\nasync function init(input) {\n    if (typeof input === \"undefined\") {\n        input = new URL(\"cardano_message_signing_bg.wasm\", import.meta.url);\n    }\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n        var ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n        var ret = debugString(getObject(arg1));\n        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_rethrow = function (arg0) {\n        throw takeObject(arg0);\n    };\n    if (typeof input === \"string\" ||\n        (typeof Request === \"function\" && input instanceof Request) ||\n        (typeof URL === \"function\" && input instanceof URL)) {\n        input = fetch(input);\n    }\n    const { instance, module } = await load(await input, imports);\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    return wasm;\n}\nexport default init;\n"],"names":["wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","memory","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","isLikeNone","x","cachegetFloat64Memory0","LabelKind","Object","freeze","Int","Text","SignedMessageKind","COSESIGN","COSESIGN1","SigContext","Signature","Signature1","CounterSignature","CBORSpecialType","Bool","Float","Unassigned","Break","Undefined","Null","CBORValueKind","Bytes","TaggedCBOR","Special","AlgorithmId","EdDSA","ChaCha20Poly1305","KeyType","OKP","EC2","Symmetric","ECKey","CRV","X","Y","D","CurveType","P256","P384","P521","X25519","X448","Ed25519","Ed448","KeyOperation","Sign","Verify","Encrypt","Decrypt","WrapKey","UnwrapKey","DeriveKey","DeriveBits","BigNum","this","__destroy_into_raw","__wbg_bignum_free","retptr","__wbindgen_add_to_stack_pointer","bignum_to_bytes","r0","r1","v0","__wbindgen_free","bignum_to_str","other","bignum_checked_mul","__wrap","bignum_checked_add","bignum_checked_sub","create","prototype","bytes","ptr0","__wbindgen_malloc","len0","bignum_from_bytes","string","__wbindgen_realloc","bignum_from_str","CBORArray","__wbg_cborarray_free","cborarray_to_bytes","cborarray_len","index","cborarray_get","CBORValue","elem","cborarray_add","use_definite","cborarray_set_definite_encoding","cborarray_is_definite","cborarray_from_bytes","cborarray_new","CBORObject","__wbg_cborobject_free","cborobject_to_bytes","cborobject_len","key","value","cborobject_insert","cborobject_get","cborobject_keys","cborobject_set_definite_encoding","cborobject_is_definite","cborobject_from_bytes","cborobject_new","CBORSpecial","__wbg_cborspecial_free","cborspecial_to_bytes","cborspecial_kind","cborspecial_as_bool","cborspecial_as_float","Float64Array","cborspecial_as_unassigned","cborspecial_from_bytes","b","cborspecial_new_bool","u","cborspecial_new_unassigned","cborspecial_new_break","cborspecial_new_null","cborspecial_new_undefined","__wbg_cborvalue_free","cborvalue_to_bytes","cborvalue_kind","cborvalue_as_int","cborvalue_as_bytes","cborvalue_as_text","cborvalue_as_array","cborvalue_as_object","cborvalue_as_tagged","cborvalue_as_special","cborvalue_from_bytes","int","cborvalue_new_int","cborvalue_new_bytes","text","cborvalue_new_text","arr","cborvalue_new_array","cborvalue_new_object","tagged","cborvalue_new_tagged","special","cborvalue_new_special","label","Label","cborvalue_from_label","COSEEncrypt","__wbg_coseencrypt_free","coseencrypt_to_bytes","coseencrypt0_headers","Headers","coseencrypt0_ciphertext","coseencrypt_recipients","COSERecipients","coseencrypt_from_bytes","headers","ciphertext","recipients","coseencrypt_new","COSEEncrypt0","__wbg_coseencrypt0_free","coseencrypt0_to_bytes","coseencrypt0_from_bytes","coseencrypt0_new","COSEKey","__wbg_cosekey_free","cosekey_to_bytes","key_type","cosekey_set_key_type","cosekey_key_type","key_id","cosekey_set_key_id","cosekey_key_id","algorithm_id","cosekey_set_algorithm_id","cosekey_algorithm_id","key_ops","Labels","cosekey_set_key_ops","cosekey_key_ops","base_init_vector","cosekey_set_base_init_vector","cosekey_base_init_vector","cosekey_header","cosekey_set_header","cosekey_from_bytes","cosekey_new","COSERecipient","__wbg_coserecipient_free","coserecipient_to_bytes","coserecipient_from_bytes","__wbg_coserecipients_free","coserecipients_to_bytes","coserecipients_len","coserecipients_get","coserecipients_add","coserecipients_from_bytes","coserecipients_new","COSESign","__wbg_cosesign_free","cosesign_to_bytes","cosesign_signatures","COSESignatures","cosesign_from_bytes","payload","signatures","cosesign_new","COSESign1","__wbg_cosesign1_free","cosesign1_to_bytes","cosesign1_signature","external_aad","external_payload","ptr1","len1","cosesign1_signed_data","SigStructure","cosesign1_from_bytes","signature","cosesign1_new","COSESign1Builder","__wbg_cosesign1builder_free","cosesign1builder_hash_payload","cosesign1builder_set_external_aad","cosesign1builder_make_data_to_sign","signed_sig_structure","cosesign1builder_build","is_payload_external","cosesign1builder_new","COSESignBuilder","__wbg_cosesignbuilder_free","cosesignbuilder_make_data_to_sign","cosesignbuilder_build","cosesignbuilder_new","COSESignature","__wbg_cosesignature_free","cosesignature_to_bytes","cosesignature_signature","cosesignature_from_bytes","cosesignature_new","__wbg_cosesignatures_free","cosesignatures_to_bytes","cosesignatures_get","cosesignatures_add","cosesignatures_from_bytes","__wbg_countersignature_free","countersignature_to_bytes","countersignature_signatures","countersignature_from_bytes","cose_signature","countersignature_new_single","cose_signatures","countersignature_new_multi","EdDSA25519Key","__wbg_eddsa25519key_free","private_key_bytes","eddsa25519key_set_private_key","eddsa25519key_is_for_signing","eddsa25519key_is_for_verifying","eddsa25519key_build","pubkey_bytes","eddsa25519key_new","HeaderMap","__wbg_headermap_free","headermap_to_bytes","headermap_set_algorithm_id","headermap_algorithm_id","criticality","headermap_set_criticality","headermap_criticality","content_type","headermap_set_key_id","headermap_key_id","init_vector","partial_init_vector","headermap_set_partial_init_vector","headermap_partial_init_vector","counter_signature","headermap_set_counter_signature","headermap_counter_signature","headermap_header","headermap_set_header","headermap_keys","headermap_from_bytes","headermap_new","__wbg_headers_free","headers_to_bytes","headers_protected","ProtectedHeaderMap","headers_unprotected","headers_from_bytes","protected_","unprotected_","headers_new","__wbg_int_free","int_is_positive","int_as_positive","int_as_negative","int_as_i32","int_new","int_new_negative","int_new_i32","__wbg_label_free","label_to_bytes","label_kind","label_as_int","label_as_text","label_from_bytes","label_new_int","label_new_text","id","label_from_algorithm_id","label_from_key_type","ec_key","label_from_ec_key","curve_type","label_from_curve_type","key_op","label_from_key_operation","__wbg_labels_free","labels_to_bytes","labels_get","labels_add","labels_from_bytes","PasswordEncryption","__wbg_passwordencryption_free","passwordencryption_to_bytes","passwordencryption_from_bytes","data","passwordencryption_new","__wbg_protectedheadermap_free","protectedheadermap_to_bytes","protectedheadermap_deserialized_headers","protectedheadermap_from_bytes","protectedheadermap_new_empty","header_map","protectedheadermap_new","PubKeyEncryption","__wbg_pubkeyencryption_free","pubkeyencryption_to_bytes","pubkeyencryption_from_bytes","pubkeyencryption_new","__wbg_sigstructure_free","sigstructure_to_bytes","sigstructure_context","sigstructure_body_protected","sigstructure_sign_protected","sigstructure_external_aad","sigstructure_payload","sign_protected","sigstructure_set_sign_protected","sigstructure_from_bytes","context","body_protected","sigstructure_new","SignedMessage","__wbg_signedmessage_free","signedmessage_to_bytes","signedmessage_to_user_facing_encoding","signedmessage_kind","signedmessage_as_cose_sign","signedmessage_as_cose_sign1","signedmessage_from_bytes","cose_sign","signedmessage_new_cose_sign","cose_sign1","signedmessage_new_cose_sign1","s","signedmessage_from_user_facing_encoding","__wbg_taggedcbor_free","taggedcbor_to_bytes","taggedcbor_tag","taggedcbor_value","taggedcbor_from_bytes","tag","taggedcbor_new","load","module","imports","Response","WebAssembly","instantiateStreaming","get","console","warn","arrayBuffer","instantiate","Instance","init","input","URL","wbg","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","Request","fetch","exports","__wbindgen_wasm_module"],"sourceRoot":""}